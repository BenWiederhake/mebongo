// wasm-pack build --target web

#[macro_use]
extern crate lazy_static;
#[macro_use]
extern crate static_assertions;

use wasm_bindgen::prelude::*;

mod board;
mod search;
mod tile;

pub const VERSION: usize = 42;

#[wasm_bindgen]
pub fn check_config(
    version: usize,
    max_board_w: u8,
    max_board_h: u8,
    max_tile_size: u8,
    total_tiles: usize,
) -> u32 {
    if version != VERSION {
        return 1;
    }
    if max_board_w != board::MAX_WIDTH {
        return 2;
    }
    if max_board_h != board::MAX_HEIGHT {
        return 3;
    }
    if max_tile_size != tile::MAX_SIZE {
        return 4;
    }
    if total_tiles != tile::ALL_TILES.len() {
        return 5;
    }

    // Random number that is unlikely to have been generated by accident:
    134250805
}

const CELL_TO_TILE_LENGTH: usize = (board::MAX_WIDTH * board::MAX_HEIGHT) as usize;

#[derive(Debug, PartialEq)]
#[wasm_bindgen]
pub struct Result {
    pub steps_taken: usize,
    pub has_solution: bool,
    pub has_finished: bool,
    // Ugh. Wasm doesn't know how to deal with small arrays like [u8; CELL_TO_TILE_LENGTH]:
    // > the trait `IntoWasmAbi` is not implemented for `[u8; 30]`
    // > the trait `FromWasmAbi` is not implemented for `[u8; 30]`
    pub row0: u64,
    pub row1: u64,
    pub row2: u64,
    pub row3: u64,
    pub row4: u64,
    pub row5: u64,
}

fn extract_row(cell_to_tile: [u8; CELL_TO_TILE_LENGTH], row_index: usize) -> u64 {
    let mut result = 0;
    for column in 0..(board::MAX_WIDTH as usize) {
        result <<= 8;
        result |= cell_to_tile[row_index * board::MAX_WIDTH as usize + column] as u64;
    }
    result
}

impl Result {
    fn new(
        steps_taken: usize,
        has_solution: bool,
        has_finished: bool,
        cell_to_tile: [u8; CELL_TO_TILE_LENGTH],
    ) -> Result {
        Result {
            steps_taken,
            has_solution,
            has_finished,
            row0: extract_row(cell_to_tile, 0),
            row1: extract_row(cell_to_tile, 1),
            row2: extract_row(cell_to_tile, 2),
            row3: extract_row(cell_to_tile, 3),
            row4: extract_row(cell_to_tile, 4),
            row5: extract_row(cell_to_tile, 5),
        }
    }
}

fn decode_tile_indices(tiles_encoded: u32) -> Vec<usize> {
    let mut tile_indices = Vec::new();
    for tile_index in 0..tile::ALL_TILES.len() {
        if 0 != tiles_encoded & (1 << (tile::ALL_TILES.len() - 1 - tile_index)) {
            tile_indices.push(tile_index);
        }
    }
    tile_indices
}

fn paint_cells(
    board: &board::Board,
    steps: &search::Result,
    tile_lookup: &[usize],
) -> [u8; CELL_TO_TILE_LENGTH] {
    // 255 for black (not part of the board) and 254 for white (available but unused).
    let mut cells = [255; CELL_TO_TILE_LENGTH];
    for y in 0..board::MAX_HEIGHT {
        for x in 0..board::MAX_WIDTH {
            if board.is_blocked_at(x, y) {
                continue;
            }
            let cell_index = x + board::MAX_WIDTH * y;
            cells[cell_index as usize] = 254;
        }
    }
    for operation in steps {
        // Note that the 'tile_index' refers to the index in the '&[Tile]' given to
        // 'State::new()'. We need to translate that to the index in 'tile::ALL_TILES'.
        let local_tile_index = operation.indexed_tile_layout.tile_index;
        let global_tile_index = tile_lookup[local_tile_index as usize];
        let tile = &tile::ALL_TILES[global_tile_index];
        let layout = &tile.get_layouts()[operation.indexed_tile_layout.layout_index as usize];
        for y in 0..tile::MAX_SIZE {
            for x in 0..tile::MAX_SIZE {
                if !layout.is_present_at(x, y) {
                    continue;
                }
                let cell_index = (x + operation.dx) + board::MAX_WIDTH * (y + operation.dy);
                cells[cell_index as usize] = global_tile_index as u8;
            }
        }
    }
    cells
}

#[wasm_bindgen]
pub fn compute_result(tiles_encoded: u32, board_encoded: u32, max_steps: usize) -> Result {
    let tile_indices = decode_tile_indices(tiles_encoded);
    let tiles = tile_indices
        .iter()
        .map(|&i| tile::ALL_TILES[i].clone())
        .collect::<Vec<_>>();
    let board = board::Board::from_encoded(board_encoded);
    let mut search_state = search::State::new(board.clone(), &tiles);
    let (steps_taken, raw_result) = search_state.step_at_most(max_steps);
    let (has_solution, cell_to_tile) = match raw_result {
        None => (false, [255; CELL_TO_TILE_LENGTH]),
        Some(steps) => (true, paint_cells(&board, &steps, &tile_indices)),
    };
    Result::new(
        steps_taken,
        has_solution,
        !search_state.can_step(),
        cell_to_tile,
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_decode_tiles() {
        assert_eq!(decode_tile_indices(0x000), vec![]);
        assert_eq!(decode_tile_indices(0x001), vec![11]);
        assert_eq!(decode_tile_indices(0x002), vec![10]);
        assert_eq!(decode_tile_indices(0x004), vec![9]);
        assert_eq!(decode_tile_indices(0x008), vec![8]);
        assert_eq!(decode_tile_indices(0x010), vec![7]);
        assert_eq!(decode_tile_indices(0x020), vec![6]);
        assert_eq!(decode_tile_indices(0x040), vec![5]);
        assert_eq!(decode_tile_indices(0x080), vec![4]);
        assert_eq!(decode_tile_indices(0x100), vec![3]);
        assert_eq!(decode_tile_indices(0x200), vec![2]);
        assert_eq!(decode_tile_indices(0x400), vec![1]);
        assert_eq!(decode_tile_indices(0x800), vec![0]);
        assert_eq!(decode_tile_indices(0x123), vec![3, 6, 10, 11]);
        assert_eq!(
            decode_tile_indices(0xFFF),
            vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        );
    }

    #[test]
    fn test_simple_positive() {
        #[rustfmt::skip]
        assert_eq!(
            // LSB ·XX··
            //     XXXX·
            //     ·XXXX
            //     ·XXX·
            //     ·····
            //     ····· MSB
            compute_result(0x062, 0x000779E6, 100),
            Result::new(
                13,
                true,
                false,
                [
                    255, 0xA, 0x5, 255, 255,
                    0xA, 0xA, 0x5, 0x5, 255,
                    255, 0xA, 0x5, 0x6, 0x6,
                    255, 0xA, 0x6, 0x6, 255,
                    255, 255, 255, 255, 255,
                    255, 255, 255, 255, 255,
                ]
            )
        );
    }

    #[test]
    fn test_simple_negative_impossible() {
        #[rustfmt::skip]
        assert_eq!(
            // LSB X·X··
            //     XXXX·
            //     ·XXXX
            //     ·XXX·
            //     ·····
            //     ····· MSB
            compute_result(0x062, 0x000779E5, 100),
            Result::new(
                12,
                false,
                true,
                [
                    255, 255, 255, 255, 255,
                    255, 255, 255, 255, 255,
                    255, 255, 255, 255, 255,
                    255, 255, 255, 255, 255,
                    255, 255, 255, 255, 255,
                    255, 255, 255, 255, 255,
                ]
            )
        );
    }

    #[test]
    fn test_simple_negative_timeout() {
        #[rustfmt::skip]
        assert_eq!(
            // LSB ·XX··
            //     XXXX·
            //     ·XXXX
            //     ·XXX·
            //     ·····
            //     ····· MSB
            compute_result(0x062, 0x000779E6, 10),
            Result::new(
                10,
                false,
                false,
                [
                    255, 255, 255, 255, 255,
                    255, 255, 255, 255, 255,
                    255, 255, 255, 255, 255,
                    255, 255, 255, 255, 255,
                    255, 255, 255, 255, 255,
                    255, 255, 255, 255, 255,
                ]
            )
        );
    }
}
